import{_ as e,c as t,o as l,a0 as r}from"./chunks/framework.CUtHynuh.js";const h=JSON.parse('{"title":"请求/响应","description":"","frontmatter":{"title":"请求/响应","outline":"deep"},"headers":[],"relativePath":"mqtt/basic/request-response.md","filePath":"mqtt/basic/request-response.md"}'),i={name:"mqtt/basic/request-response.md"};function a(n,o,s,p,d,c){return l(),t("div",null,o[0]||(o[0]=[r('<h1 id="请求-响应" tabindex="-1">请求/响应 <a class="header-anchor" href="#请求-响应" aria-label="Permalink to &quot;请求/响应&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#一、核心属性支持">一、核心属性支持</a><ul><li><a href="#_1-响应主题-response-topic">1. 响应主题（Response Topic）</a></li><li><a href="#_2-关联数据-correlation-data">2. 关联数据（Correlation Data）</a></li><li><a href="#_3-响应信息-response-information">3. 响应信息（Response Information）</a></li></ul></li><li><a href="#二、操作流程">二、操作流程</a><ul><li><a href="#_1-请求方步骤">1. 请求方步骤</a></li><li><a href="#_2-响应方步骤">2. 响应方步骤</a></li></ul></li><li><a href="#三、最佳实践建议">三、最佳实践建议</a></li><li><a href="#四、示例场景">四、示例场景</a></li><li><a href="#总结">总结</a></li></ul></nav><p><a href="https://www.emqx.com/zh/blog/mqtt5-request-response" target="_blank" rel="noreferrer">https://www.emqx.com/zh/blog/mqtt5-request-response</a></p><p>MQTT 5实现请求/响应的主要方法如下：</p><h2 id="一、核心属性支持" tabindex="-1"><strong>一、核心属性支持</strong> <a class="header-anchor" href="#一、核心属性支持" aria-label="Permalink to &quot;**一、核心属性支持**&quot;">​</a></h2><h3 id="_1-响应主题-response-topic" tabindex="-1">1. <strong>响应主题（Response Topic）</strong> <a class="header-anchor" href="#_1-响应主题-response-topic" aria-label="Permalink to &quot;1. **响应主题（Response Topic）**&quot;">​</a></h3><ul><li><p><strong>作用</strong>：请求方在请求消息中指定专属的响应主题，响应方按该主题返回结果，避免多请求方的响应混淆。</p></li><li><p><strong>实现方式</strong>：</p><ul><li><p>请求方在消息中通过 <code>WithResponseTopic()</code> 设置响应主题（如包含自身 <code>Client ID</code>，例如 <code>result/to/{clientId}</code>）。</p></li><li><p>响应方解析请求中的响应主题，直接向该主题发布响应消息。</p></li></ul></li><li><p><strong>优势</strong>：每个请求方使用唯一响应主题，确保响应精准匹配。</p></li></ul><h3 id="_2-关联数据-correlation-data" tabindex="-1">2. <strong>关联数据（Correlation Data）</strong> <a class="header-anchor" href="#_2-关联数据-correlation-data" aria-label="Permalink to &quot;2. **关联数据（Correlation Data）**&quot;">​</a></h3><ul><li><p><strong>作用</strong>：请求方在请求中携带唯一标识（如 <code>GUID</code>），响应方原封不动返回，用于匹配请求与响应。</p></li><li><p><strong>实现方式</strong>：</p><ul><li><p>请求方通过 <code>WithCorrelationData()</code> 设置关联数据（如字节数组形式的唯一ID）。</p></li><li><p>响应方从请求中提取关联数据，在响应中携带相同数据。</p></li></ul></li><li><p><strong>优势</strong>：解决响应乱序、网络中断等场景下的请求-响应匹配问题，支持多响应方场景。</p></li></ul><h3 id="_3-响应信息-response-information" tabindex="-1">3. <strong>响应信息（Response Information）</strong> <a class="header-anchor" href="#_3-响应信息-response-information" aria-label="Permalink to &quot;3. **响应信息（Response Information）**&quot;">​</a></h3><ul><li><p><strong>作用</strong>：应对服务端主题权限限制，客户端通过连接时请求服务端返回 <code>响应信息</code>，用于构建符合权限的响应主题。</p></li><li><p><strong>实现方式</strong>：</p><ul><li><p>客户端在 <code>CONNECT</code> 报文中设置 <code>Request Response Information = 1</code>。</p></li><li><p>服务端在 <code>CONNACK</code> 中返回 <code>Response Information</code>（如用户ID、主题前缀等），客户端按约定规则拼接响应主题（如 <code>{responseInfo}/result</code>）。</p></li></ul></li><li><p><strong>优势</strong>：动态生成合规的响应主题，绕过权限限制。</p></li></ul><h2 id="二、操作流程" tabindex="-1"><strong>二、操作流程</strong> <a class="header-anchor" href="#二、操作流程" aria-label="Permalink to &quot;**二、操作流程**&quot;">​</a></h2><h3 id="_1-请求方步骤" tabindex="-1">1. <strong>请求方步骤</strong> <a class="header-anchor" href="#_1-请求方步骤" aria-label="Permalink to &quot;1. **请求方步骤**&quot;">​</a></h3><ol><li><p><strong>创建请求消息</strong>：</p><ul><li><p>指定请求主题（如 <code>cmnd/device/control</code>）。</p></li><li><p>设置 <code>响应主题</code>（如 <code>state/device/{clientId}</code>）和 <code>关联数据</code>（如唯一ID）。</p></li></ul></li><li><p><strong>发送请求</strong>：向请求主题发布消息。</p></li><li><p><strong>订阅响应主题</strong>：提前订阅自身指定的响应主题，等待接收响应。</p></li><li><p><strong>解析响应</strong>：通过关联数据匹配响应与原始请求，处理结果。</p></li></ol><h3 id="_2-响应方步骤" tabindex="-1">2. <strong>响应方步骤</strong> <a class="header-anchor" href="#_2-响应方步骤" aria-label="Permalink to &quot;2. **响应方步骤**&quot;">​</a></h3><ol><li><p><strong>监听请求主题</strong>：订阅请求主题（如 <code>cmnd/device/control</code>）。</p></li><li><p><strong>解析请求</strong>：提取请求中的 <code>响应主题</code> 和 <code>关联数据</code>。</p></li><li><p><strong>处理请求并生成响应</strong>：按请求内容执行操作（如设备控制），构建包含原 <code>关联数据</code> 的响应消息。</p></li><li><p><strong>发布响应</strong>：向请求中的 <code>响应主题</code> 发布响应消息。</p></li></ol><h2 id="三、最佳实践建议" tabindex="-1"><strong>三、最佳实践建议</strong> <a class="header-anchor" href="#三、最佳实践建议" aria-label="Permalink to &quot;**三、最佳实践建议**&quot;">​</a></h2><ol><li><p><strong>主题设计</strong>：</p><ul><li><p>多请求方场景：使用 <code>Client ID</code> 作为响应主题的一部分（如 <code>result/{clientId}</code>），避免主题冲突。</p></li><li><p>多响应方场景：请求方必须设置 <code>关联数据</code>，确保响应正确匹配。</p></li></ul></li><li><p><strong>权限管理</strong>：</p><ul><li>利用 <code>响应信息</code> 动态生成符合服务端权限的响应主题（如以用户ID为前缀）。</li></ul></li><li><p><strong>QoS 配置</strong>：</p><ul><li>请求和响应消息建议使用 <strong>QoS 1 或 2</strong>，确保消息可靠传输，避免丢失。</li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li>请求方设置超时机制（如等待10秒未收到响应则报错），处理网络延迟或响应方故障。</li></ul></li></ol><h2 id="四、示例场景" tabindex="-1"><strong>四、示例场景</strong> <a class="header-anchor" href="#四、示例场景" aria-label="Permalink to &quot;**四、示例场景**&quot;">​</a></h2><p>以智能家居为例：</p><ul><li><p><strong>请求方（手机）</strong>：</p><ul><li><p>发布请求到主题 <code>cmnd/light/bedroom/power</code>，设置响应主题 <code>state/light/bedroom/{phoneId}</code> 和关联数据 <code>UUID-123</code>。</p></li><li><p>订阅响应主题 <code>state/light/bedroom/{phoneId}</code>。</p></li></ul></li><li><p><strong>响应方（智能灯）</strong>：</p><ul><li><p>收到请求后，解析响应主题和关联数据，执行开灯操作。</p></li><li><p>向响应主题 <code>state/light/bedroom/{phoneId}</code> 发布响应，携带关联数据 <code>UUID-123</code> 和结果 <code>ON</code>。</p></li></ul></li><li><p><strong>匹配逻辑</strong>：请求方通过关联数据 <code>UUID-123</code> 确认响应属于自身请求。</p></li></ul><h2 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h2><p>MQTT 5通过 <strong>响应主题</strong>、<strong>关联数据</strong> 和 <strong>响应信息</strong> 三大核心属性，标准化了请求/响应流程，解决了传统方案中主题冲突、响应匹配混乱和权限限制等问题，使异步通信框架下的同步交互成为可能，适用于物联网设备控制、远程调用等场景。</p>',23)]))}const u=e(i,[["render",a]]);export{h as __pageData,u as default};
